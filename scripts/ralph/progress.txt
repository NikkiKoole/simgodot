## Codebase Patterns

- Use GDScript explicit type annotations for variables assigned from function returns (e.g., `var x: bool = func()`) to avoid type inference errors
- Use `is_instance_valid(node)` instead of `node != null` for null checks - handles both null and freed nodes
- Test files follow pattern: `test_*.gd` with matching `test_*.tscn` scene
- Stations use tags array for recipe matching (e.g., ["counter"], ["stove", "cooking"])
- Items track location via LocationState enum: ON_GROUND, IN_CONTAINER, AT_STATION, HELD_BY_NPC
- Jobs track progress via current_step_index through recipe steps array
- JobBoard is autoload singleton for global job management
- Recipes are .tres Resource files in resources/recipes/
- DebugCommands will be the API layer - all debug functionality flows through it for testability

---

## 2026-01-09 - PRD Created

- Created prd.json with 21 user stories for Debug & Testing UI system
- User stories organized in 4 phases:
  - Phase 1 (US-001 to US-007): DebugCommands API - testable foundation
  - Phase 2 (US-008 to US-013): Visual UI framework and inspectors
  - Phase 3 (US-014 to US-016): Spawn and manipulation tools
  - Phase 4 (US-017 to US-021): Visualizations and integration tests
- Key architectural decision: DebugCommands singleton as API layer enables headless testing
- Gap analysis included: need counter, stove, sink, couch stations (use generic station.tscn with tags)
- Required items: raw_food, toilet_paper, remote, cooked_meal, prepped_food

**Learnings for future iterations:**
- Build API layer first (DebugCommands) before visual UI
- All spawn/manipulation operations should emit signals for UI updates
- Scenario save/load enables repeatable test setups
- ~80% of debug functionality can be tested headlessly through API

---

## 2026-01-09 - US-001
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented DebugCommands singleton as autoload
- Added select_entity() with entity_selected/entity_deselected signals
- Added get_inspection_data() returning Dictionary with type-specific properties:
  - NPC: type, state, motives (hunger/energy/bladder/hygiene/fun), held_item, current_job
  - Station: type, tags, slot_contents (input_slots/output_slots), current_user
  - ItemEntity: type, item_tag, location_state, container
  - Container: type, name, tags, items, capacity, used
- Created test_debug_commands.gd with 46 assertions covering all inspection data types
- Added test to run_tests.sh - all 12 test suites pass (771 total assertions)

**Files changed:**
- scripts/debug_commands.gd (new)
- scripts/tests/test_debug_commands.gd (new)
- scenes/tests/test_debug_commands.tscn (new)
- project.godot (added DebugCommands autoload)
- run_tests.sh (added test_debug_commands)
- AGENTS.md (documented Motive is RefCounted, not Node)

**Learnings for future iterations:**
- Autoload singletons must NOT use `class_name` - causes "hides an autoload singleton" error
- `Motive` class is `RefCounted` not `Node` - use correct type annotation
- Container class in Godot is reserved - project uses `ItemContainer` instead
- NPC uses `held_items` (array) not `held_item` (single)
- Signal tests with lambdas can be tricky - verify state directly when possible
- GDScript closures cannot capture and modify local variables directly - use arrays to capture mutable state

---

## 2026-01-09 - US-002
Thread: https://ampcode.com/threads/$AMP_CURRENT_THREAD_ID
- Implemented spawn_item(tag, position_or_target) in DebugCommands
- Handles 3 spawn target types:
  - Vector2: spawns item ON_GROUND at world position
  - ItemContainer: spawns item IN_CONTAINER
  - Station: spawns item in first available input slot
- Returns spawned ItemEntity reference, emits item_spawned signal
- Added _get_level_node() helper to find Level node or fallback to scene root
- Added 7 new tests covering all spawn scenarios (22 new assertions)
- All 12 test suites pass (793 total assertions)

**Files changed:**
- scripts/debug_commands.gd (added spawn_item and helpers)
- scripts/tests/test_debug_commands.gd (added spawn tests)

**Learnings for future iterations:**
- GDScript closures cannot capture and modify local primitives - use Array to capture mutable values in signal callbacks
- Spawning entities requires adding to scene tree first, then reparenting occurs via container/station methods
- Use "level" group to find Level node for spawning, with fallback to current_scene root

---
